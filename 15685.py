# BOJ_15685
# 드래곤 커브

"""
드래곤 커브는 최대 10세대까지 존재.
1. N세대 드래곤 커브 만든다고 가정.
2. N-1세대 드래곤 커브를 우선 복사하고, 이것을 시계 방향으로 90도 회전.
3. 회전시킨 드래곤 커브를 N-1세대 드래곤 커브의 마지막에 이어 붙인다.
4. 1~3 과정을 입력으로 주어진 세대까지 반복.

- 쉽게 구현하기 위해, 드래곤 커브를 좌표 대신 방향을 사용
- 첫 출발 방향을 0(오른쪽)으로 둔다.
- 이전 세대의 마지막 방향에서 출발 방향까지 거꾸로 탐색하면서, 각 방향에 1을 더하고 move에 저장. (%4 연산 필요)
- 마지막으로, 사각형 좌표 (X,Y), (X+1,Y), (X,Y+1), (X+1,Y+1)를 체크해서 모두 존재하면, 정답을 1 카운트.
- (0,0)부터 (100,100)까지 모두 확인한 후, 정답 개수 출력.
"""

"""
오답 분석
- 정확한 문제(지문) 이해 부족
- 아이디어 부족
입력으로 주어지는 각 점들에 대해서 따로 따로 최대 세대까지 구하는 방법으로 접근.
90도가 돌아가는 부분을 dy, dx로 구현하는 것을 생각 못함.
한 세대가 지날 때마다, 끝점을 시작으로 역순으로 점들에 접근해서 이동 방향에 대해 (move[-i-1] + 1)%4)를 하면 90도 회전을 표현 가능.

- 문제를 풀 때, step-1 과 step과의 변화를 주석으로 서술해보면서 알고리즘 순서를 만들어볼 것. 
"""

import sys
input = sys.stdin.readline

# 동, 남, 서, 북
dx = [1, 0, -1, 0]
dy = [0, -1, 0, 1]

N = int(input())
board = [[0]*101 for _ in range(101)]
for _ in range(N):
    x, y, d, g = map(int, input().split())
    board[x][y] = 1
    move = [d]
    for _ in range(g):
        temp = []
        for i in range(len(move)):
            temp.append((move[-i-1] + 1) % 4)  # 뒤에서부터 추가
        move.extend(temp)
    # 리스트에 있는 이동 방향을 이용하려면 리스트의 맨 뒤부터 시작해서 이동해야
    # 이전 좌표를 기준으로 이용할 수 있다.
    for i in move:
        nx = x + dx[i]
        ny = y + dy[i]
        board[nx][ny] = 1
        x, y = nx, ny

# 사각형 갯수 카운트
ans = 0
for i in range(100):
    for j in range(100):
        if board[i][j]:
            if board[i+1][j] and board[i][j+1] and board[i+1][j+1]:
                ans += 1

print(ans)